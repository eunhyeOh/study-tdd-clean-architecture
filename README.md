# 동시성 제어 방식에 대한 분석

### 관련 개념

- 직렬화 (Serialization)
    - 하나의 작업이 완료된 후 다음 작업이 수행되는 방식
    - 유저 ID 단위로 요청을 직렬화 한다는 것은 동일한 유저 ID를 대상으로 한 요청이 순서대로 처리된다는 의미
    - Ex. 유저 A에 대해 요청 1이 끝난 후에 요청 2가 처리됨
- 병렬 요청 (Concurrent Requests)
    - 여러 요청이 동시에 실행되는 방식
    - 병렬 요청 테스트 목적은 시스템이 동시에 들어온 요청을 적절히 처리하며 데이터 정합성을 보장하는지 확인하는 것
    - Ex. 유저 A의 요청 1과 요청 2가 동시에 실행됨. 시스템이 이것을 적절히 직렬화 해야함.

---

### 구현 Keyword

- `ConcurrentHashMap`
    - 멀티 스레드 환경에서 안전하게 사용할 수 있는 데이터 구조(Map)
    - 여러 스레드가 동시에 맵에 접근해도 E**ntry 아이템별로 락**을 걸어서 데이터를 안전하게 관리할 수 있다.
    - 유저의 요청을 처리하는 동안, 각 유저별로 요청이 충돌하지 않도록 관리해준다.
    - 다른 Map구현체와의 차이??
        - `HashMap`
            - 동기화 처리를 하지 않기 때문에 안정성이 떨어져 멀티 스레드 환경에서는 사용하면 좋지 않다.(**싱글 스레드 환경**에서 사용권장)
        - `HashTable`
            - Synchronized 키워드를 이용해서 스레드간 동기화 락을 걸어 멀티 스레드 환경에서도 안전하나, 스레드간 동기화 락은 **매우 느리다**.
        
- `ReentrantLock`
    - 특정 코드 블록에 대한 **순차적 접근**을 보장해준다.
    - lock(), unlock()으로 시작과 끝을 명시하기 때문에 여러 메서드에 나눠서 작성할 수 있다.
    - 명시적인 메서드를 호출함으로써 어떤스레드가 먼저 락을 획득하게 될지 순서를 지정할 수 있다.
    - 특정 유저가 요청을 보낼 때, 그 유저의 요청에 대해서만 하나의 스레드만 처리할 수 있도록 하고, 다른 스레드는 그 유저에 대한 처리가 끝날 때까지 대기하도록 해준다.
    - 비슷한게 있는데 왜 `Synchronized` 말고 `ReentrantLock` 을 썼을까?
        - `Synchronized`
            - 현재 데이터를 사용하고 있는 해당 스레드를 제외하고 나머지 스레드들은 데이터에 접근할 수 없도록 막는 개념
            - 메서드 앞에 Synchronized 키워드를 걸면 그 함수가 포함된 해당 객체에 lock이 걸린다.(임계 영역 범위가 있음)
            - 스레드 진입 획득 순서의 보장이 되지 않는다.
            - 단점
                - 내부적으로 메서드나 변수에 동기화를 위해 block과 unblock 처리를 하게 되는데 너무 많이 사용하게 되면 프로그램 성능 저하 될 수 있음

### 구현 방법

- `ConcurrentHashMap`을 사용하여 유저별로 `ReentrantLock`을 저장한다.
- 이를 통해 특정 유저의 요청이 들어올 때, 그 유저에 대한 요청을 잠그고 순차적으로 처리할 수 있다.
- 각 메소드에서 `ReentrantLock`을 사용하여 해당 유저의 요청을 처리하기 전에 락을 걸고, 처리가 끝나면 락을 해제한다.

---

### 현 과제에서 동시성 제어 구현 Layer 선택시 고려사항

**결론 먼저**

1. 컨트롤러에서 동시성 제어 :  HTTP 요청의 초점에서 간단히 처리할 때 적합하다. 컨트롤러 단위로 동작하는 애플리케이션에 적합하다.
2. 서비스 레이어에서 동시성 제어 : 비즈니스 로직 중심의 일관된 동시성 처리가 필요할 때 적합하다. 규모가 크고 복잡한 시스템에 적합하다.

### Service Layer에서 동시성 제어

- 장점
    - 컨트롤러는 요청 처리와 서비스 호출만 담당하게 되므로 관심사를 분리시킬 수 있다.
    - 동일한 동시성 제어 로직이 다른 컨트롤러에서 호출되어도 재사용할 수 있다.
    - 특정 리소스에 대한 동시성 제어가 서비스 레이어에서 통합적으로 관리되므로, 여러 컨트롤러가 동일 리소스를 수정할 때도 안전하다.
- 단점
    - 유저별로 동시성 제어를 위해 `ConcurrentHashMap`과 `ReentrantLock`을 사용하면, 유저가 많아질수록 메모리 사용량이 늘어날 수 있다.
    - 동시 요청이 많아지고, 유저별 요청이 ㅠ에 대기하게 되면 응답 시간이 길어질 수 있다.
    - 비즈니스 로직과 동시성 제어 로직이 섞여 유지보수가 어려워 질 수 있다.
    - 분산 환경에서 동시성 제어 문제가 있을 수 있다. 단일 애플리케이션 인스턴스 내에서만 작동하게 되는데, 여러 대의 서버 인스턴스에서 실행이 된다면, 분산 락을 별도로 구현해야 할 수도 있다. (Redis, Zookeeper 등과 같은 외부 시스템을 사용한 분산 락..)

### Controller Layer에서 동시성 제어

- 장점
    - HTTP 요청이 들어오는 진입단계에서 락을 관리하여 유저별 요청을 직렬화 하면서 효율적으로 제어할 수 있다.
    - 서비스 레이어는 비즈니스 로직만 처리할 수 있어 서비스 레이어의 복잡도를 줄일 수 있다.
    - 컨트롤러는 HTTP 요청을 하나의 트랜잭션 단위로 처리한다. 요청이 끝난 후 락을 해제하므로 락의 생명주기를 자연스럽게 관리할 수 있다.
- 단점
    - 컨트롤러는 보통 요청을 처리하고 서비스 레이어에 위임하는 역할이나, 동시성 제어 로직이 추가되면 책임이 증가해서 코드가 복잡해질 우려가 있다.
    - 서비스 단위 테스트에서 동시성 제어 검증이 어렵고 테스트 복잡도가 증가한다.
    - 여러 컨트롤러가 동일한 리소스를 수정하거나 읽게 되면 충돌 방지가 어렵다.

